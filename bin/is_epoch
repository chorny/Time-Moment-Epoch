#!/usr/bin/env perl

use v5.24;
use warnings;
use experimental 'signatures';
use Data::Printer;
use Getopt::Long;
use JSON;
use Math::BigInt try => 'GMP';
use Pod::Usage;
use Time::Moment::Epoch;

my %opt = (
	max_date => '9999-12-31T23:59:59Z',
	min_date => '0001-01-01T00:00:00Z',
	output => 'as_string',
);

GetOptions(
	\%opt,

	'max_date=s',
	'min_date=s',
	'output=s',

	'debug!',
	'help|?',
	'man',
	'verbose!',
) or pod2usage(2);
pod2usage(1) if $opt{help};
pod2usage(-verbose => 2) if $opt{man};
p %opt if $opt{debug};

my $epochs = get_epochs(@ARGV);

if ($opt{output} eq 'as_string') {
	as_string($epochs);
} elsif ($opt{output} eq 'as_json') {
	as_json($epochs);
} else {
	die "Don't know how to output '$opt{output}'";
}

sub get_epochs {
	my %epochs;
	for my $arg (@_) {

		# Floating point number.
		if ($arg =~ /^-?\d+\.\d+$/) {
			try_float(
				$arg,
				\%epochs,
			);
		}

		# Decimal number.
		if ($arg =~ /^-?\d+$/) {
			try_int(
				'decimal',
				$arg,
				$arg,
				\%epochs,
			);
		}

		# Hexadecimal number.
		if ($arg =~ /^-?[0-9a-fA-F]+$/) {
			try_int(
				'hexadecimal',
				$arg,
				Math::BigInt->new("0x$arg")->bstr,
				\%epochs,
			);
		}

		# 64-bit Hexadecimal number.
		if ($arg =~ /^[0-9a-fA-F]{16}$/) {
			try_hex64bit(
				$arg,
				\%epochs,
			);
		}

		# 128-bit Hexadecimal number.
		if ($arg =~ /^(?:0x)?[0-9a-fA-F]{32}$/) {
			try_hex128bit(
				$arg,
				\%epochs,
			);
		}

	}
	return \%epochs;
}

sub as_string ($epochs) {
	if (my $results = _stringify($epochs)) {
		say for reverse sort @{$results};
	} else {
		say "no results" if $opt{verbose};
	}
}

sub as_json ($epochs) {
	if (my $results = _stringify($epochs, 0)) {
		say encode_json($results);
	} else {
		say "no results" if $opt{verbose};
	}
}

sub _stringify ($epochs, $flatten=1) {
	my $stringified;
	for my $arg (keys $epochs->%*) {
		for my $type (keys $epochs->{$arg}->%*) {
			for my $conv (keys $epochs->{$arg}{$type}->%*) {
				my $s = $epochs->{$arg}{$type}{$conv}->to_string;
				next if $s lt $opt{min_date} or $s gt $opt{max_date};
				if ($flatten) {
					push @$stringified,
						"$epochs->{$arg}{$type}{$conv}\t($arg, $type, $conv)";
				} else {
					$stringified->{$arg}{$type}{$conv} = $s;
				}
			}
		}
	}
	return $stringified;
}

sub try_float ($arg, $epochs) {
	my @floats = qw(icq);

	no strict 'refs';
	for my $conv (@floats) {
		if (my $tm = "Time::Moment::Epoch::$conv"->($arg)) {
			$epochs->{$arg}{'float'}{$conv} = $tm;
		}
	}
}

sub try_hex64bit ($arg, $epochs) {
	my @hex64s = qw(ole);

	no strict 'refs';
	for my $conv (@hex64s) {
		if (my $tm = "Time::Moment::Epoch::$conv"->(pack 'H*', $arg)) {
			$epochs->{$arg}{'hex64bit'}{$conv} = $tm;
		}
	}
}

sub try_hex128bit ($arg, $epochs) {
	my @hex128s = qw(windows_system);

	no strict 'refs';
	for my $conv (@hex128s) {
		if (my $tm = "Time::Moment::Epoch::$conv"->($arg)) {
			$epochs->{$arg}{'hex128bit'}{$conv} = $tm;
		}
	}
}

sub try_int ($type, $orig, $arg, $epochs) {
	my @ints = qw(apfs chrome cocoa dos google_calendar
				  icq java mozilla symbian unix uuid_v1
				  windows_date windows_file);

	no strict 'refs';
	for my $conv (@ints) {
		if (my $tm = "Time::Moment::Epoch::$conv"->($arg)) {
			$epochs->{$orig}{$type}{$conv} = $tm;
		}
	}
}


__END__

=head1 NAME

is_epoch - guess if the given number is an epoch

=head1 SYNOPSIS

is_epoch [OPTIONS] number [number ...]

=head1 EXAMPLES

Default is Unix time and brief output.

    $ ./is_epoch 1234567890
    2009-02-13T23:31:30Z


=head1 OPTIONS

=over 4

=item B<--debug>

Prints extra messages.

=item B<--help>

Prints a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--max_date=STRING>

Maximum date to print out. Default is 9999-12-31T23:59:59Z. It's just a string compare, so you can include as little or as much of an ISO-8601 date as you want (e.g., --max_date=2017).

=item B<--min_date=STRING>

Minimum date to print out. Default is 0001-01-01T00:00:00Z. It's just a string compare, so you can include as little or as much of an ISO-8601 date as you want (e.g., --min_date=2017).

=item B<--output=STRING>

Output format (as_string or as_json). Default as_string.

=item B<--verbose>

Prints results in more detail.

=back

=head1 DESCRIPTION

B<is_epoch> will guess if any of the conversions from
Time::Moment::Epoch gives a reasonable date for the given numbers.

=cut

