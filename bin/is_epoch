#!/usr/bin/env perl

use v5.24;
use warnings;
use experimental 'signatures';
use Data::Printer;
use Getopt::Long;
use JSON;
use Math::BigInt try => 'GMP';
use Pod::Usage;
use Time::Moment::Epoch;

my %opt = (
	max_date => Time::Moment->now->year + 1,
	min_date => Time::Moment->now->year - 1,
	output => 'pprint',
);

GetOptions(
	\%opt,

	'max_date=s',
	'min_date=s',
	'output=s',

	'debug!',
	'help|?',
	'man',
	'verbose!',
) or pod2usage(2);
pod2usage(1) if $opt{help};
pod2usage(-verbose => 2) if $opt{man};
p %opt if $opt{debug};

my $epochs = get_epochs(@ARGV);

if ($opt{output} eq 'pprint') {
	pprint($epochs);
} elsif ($opt{output} eq 'json') {
	say json($epochs);
} else {
	die "Don't know how to output '$opt{output}'";
}

sub get_epochs {
	my %epochs;
	for my $arg (@_) {

		# Floating point number.
		if ($arg =~ /^-?\d+\.\d+$/) {
			try_float(
				$arg,
				\%epochs,
			);
		}

		# Decimal number.
		if ($arg =~ /^-?\d+$/) {
			try_int(
				'decimal',
				$arg,
				$arg,
				\%epochs,
			);
		}

		# Hexadecimal number.
		if ($arg =~ /^-?[0-9a-fA-F]+$/) {
			try_int(
				'hexadecimal',
				$arg,
				Math::BigInt->new("0x$arg")->bstr,
				\%epochs,
			);
		}

		# 64-bit Hexadecimal number.
		if ($arg =~ /^[0-9a-fA-F]{16}$/) {
			try_hex64bit(
				$arg,
				\%epochs,
			);
		}
	}
	return \%epochs;
}

sub pprint ($epochs) {

	my $stringified = _stringify($epochs);

	my @lines;
	for my $arg (keys $stringified->%*) {
		for my $type (keys $stringified->{$arg}->%*) {
			for my $conv (keys $stringified->{$arg}{$type}->%*) {
				push @lines,
					"$stringified->{$arg}{$type}{$conv}\t($arg, $type, $conv)";
			}
		}
	}

	say for	reverse	sort @lines;
}

sub json ($epochs) {
	encode_json(_stringify($epochs));
}

sub _stringify ($epochs) {
	my $stringified;
	for my $arg (keys $epochs->%*) {
		for my $type (keys $epochs->{$arg}->%*) {
			for my $conv (keys $epochs->{$arg}{$type}->%*) {
				my $s = $epochs->{$arg}{$type}{$conv}->to_string;
				next if $s lt $opt{min_date} or $s gt $opt{max_date};
				$stringified->{$arg}{$type}{$conv} = $s;
			}
		}
	}
	return $stringified;
}

sub try_float ($arg, $epochs) {
	my @floats = qw(icq);

	no strict 'refs';
	for my $conv (@floats) {
		if (my $tm = "Time::Moment::Epoch::$conv"->($arg)) {
			$epochs->{$arg}{'float'}{$conv} = $tm;
		}
	}
}

sub try_hex64bit ($arg, $epochs) {
	my @hex64s = qw(ole);

	no strict 'refs';
	for my $conv (@hex64s) {
		if (my $tm = "Time::Moment::Epoch::$conv"->(pack 'H*', $arg)) {
			$epochs->{$arg}{'hex64bit'}{$conv} = $tm;
		}
	}
}

sub try_int ($type, $orig, $arg, $epochs) {
	my @ints = qw(apfs chrome cocoa dos google_calendar
				  icq java mozilla symbian unix uuid_v1
				  windows_date windows_file);

	no strict 'refs';
	for my $conv (@ints) {
		if (my $tm = "Time::Moment::Epoch::$conv"->($arg)) {
			$epochs->{$orig}{$type}{$conv} = $tm;
		}
	}
}


__END__

=head1 NAME

is_epoch - guess if the given number is an epoch

=head1 SYNOPSIS

is_epoch [OPTIONS] number [number ...]

=head1 EXAMPLES

Default is Unix time and brief output.

    $ ./is_epoch 1234567890
    2009-02-13T23:31:30Z


=head1 OPTIONS

=over 4

=item B<--debug>

Prints extra messages.

=item B<--help>

Prints a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--max_date=STRING>

Maximum date to print out. Default next year.

=item B<--min_date=STRING>

Minimum date to print out. Default last year.

=item B<--verbose>

Prints results in more detail.

=back

=head1 DESCRIPTION

B<is_epoch> will guess if any of the conversions from
Time::Moment::Epoch gives a reasonable date for the given numbers.

=cut

